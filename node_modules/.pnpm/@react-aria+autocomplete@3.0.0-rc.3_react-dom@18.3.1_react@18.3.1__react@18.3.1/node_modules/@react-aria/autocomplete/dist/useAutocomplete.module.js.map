{"mappings":"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","sources":["packages/@react-aria/autocomplete/src/useAutocomplete.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, BaseEvent, DOMProps, FocusableElement, FocusEvents, KeyboardEvents, Node, RefObject, ValueBase} from '@react-types/shared';\nimport {AriaTextFieldProps} from '@react-aria/textfield';\nimport {AutocompleteProps, AutocompleteState} from '@react-stately/autocomplete';\nimport {CLEAR_FOCUS_EVENT, FOCUS_EVENT, getActiveElement, getOwnerDocument, isAndroid, isCtrlKeyPressed, isIOS, mergeProps, mergeRefs, useEffectEvent, useEvent, useId, useLabels, useObjectRef} from '@react-aria/utils';\nimport {dispatchVirtualBlur, dispatchVirtualFocus, getVirtuallyFocusedElement, moveVirtualFocus} from '@react-aria/focus';\nimport {getInteractionModality} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {FocusEvent as ReactFocusEvent, KeyboardEvent as ReactKeyboardEvent, useCallback, useEffect, useMemo, useRef, useState} from 'react';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface CollectionOptions extends DOMProps, AriaLabelingProps {\n  /** Whether the collection items should use virtual focus instead of being focused directly. */\n  shouldUseVirtualFocus: boolean,\n  /** Whether typeahead is disabled. */\n  disallowTypeAhead: boolean\n}\n\nexport interface InputProps<T = FocusableElement> extends DOMProps,\n  FocusEvents<T>,\n  KeyboardEvents,\n  Pick<ValueBase<string>, 'onChange' | 'value'>,\n  Pick<AriaTextFieldProps, 'enterKeyHint' | 'aria-controls' | 'aria-autocomplete' | 'aria-activedescendant' | 'spellCheck' | 'autoCorrect' | 'autoComplete'> {}\n\nexport interface AriaAutocompleteProps<T> extends AutocompleteProps {\n  /**\n   * An optional filter function used to determine if a option should be included in the autocomplete list.\n   * Include this if the items you are providing to your wrapped collection aren't filtered by default.\n   */\n  filter?: (textValue: string, inputValue: string, node: Node<T>) => boolean,\n\n  /**\n   * Whether or not to focus the first item in the collection after a filter is performed. Note this is only applicable\n   * if virtual focus behavior is not turned off via `disableVirtualFocus`.\n   * @default false\n   */\n  disableAutoFocusFirst?: boolean,\n\n  /**\n   * Whether the autocomplete should disable virtual focus, instead making the wrapped collection directly tabbable.\n   * @default false\n   */\n  disableVirtualFocus?: boolean\n}\n\nexport interface AriaAutocompleteOptions<T> extends Omit<AriaAutocompleteProps<T>, 'children'> {\n  /** The ref for the wrapped collection element. */\n  inputRef: RefObject<HTMLInputElement | null>,\n  /** The ref for the wrapped collection element. */\n  collectionRef: RefObject<HTMLElement | null>\n}\n\nexport interface AutocompleteAria<T> {\n  /** Props for the autocomplete input element. These should be passed to the input's aria hooks (e.g. useTextField/useSearchField/etc) respectively. */\n  inputProps: InputProps,\n  /** Props for the collection, to be passed to collection's respective aria hook (e.g. useMenu). */\n  collectionProps: CollectionOptions,\n  /** Ref to attach to the wrapped collection. */\n  collectionRef: RefObject<HTMLElement | null>,\n  /** A filter function that returns if the provided collection node should be filtered out of the collection. */\n  filter?: (nodeTextValue: string, node: Node<T>) => boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for an autocomplete component.\n * An autocomplete combines a text input with a collection, allowing users to filter the collection's contents match a query.\n * @param props - Props for the autocomplete.\n * @param state - State for the autocomplete, as returned by `useAutocompleteState`.\n */\nexport function useAutocomplete<T>(props: AriaAutocompleteOptions<T>, state: AutocompleteState): AutocompleteAria<T> {\n  let {\n    inputRef,\n    collectionRef,\n    filter,\n    disableAutoFocusFirst = false,\n    disableVirtualFocus = false\n  } = props;\n\n  let collectionId = useId();\n  let timeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let delayNextActiveDescendant = useRef(false);\n  let queuedActiveDescendant = useRef<string | null>(null);\n  let lastCollectionNode = useRef<HTMLElement>(null);\n\n  // For mobile screen readers, we don't want virtual focus, instead opting to disable FocusScope's restoreFocus and manually\n  // moving focus back to the subtriggers\n  let isMobileScreenReader = getInteractionModality() === 'virtual' && (isIOS() || isAndroid());\n  let [shouldUseVirtualFocus, setShouldUseVirtualFocus] = useState(!isMobileScreenReader && !disableVirtualFocus);\n  // Tracks if a collection has been connected to the autocomplete. If false, we don't want to add various attributes to the autocomplete input\n  // since it isn't attached to a filterable collection (e.g. Tabs)\n  let [hasCollection, setHasCollection] = useState(false);\n\n  useEffect(() => {\n    return () => clearTimeout(timeout.current);\n  }, []);\n\n  let updateActiveDescendant = useEffectEvent((e: Event) => {\n    // Ensure input is focused if the user clicks on the collection directly.\n    if (!e.isTrusted && shouldUseVirtualFocus && inputRef.current && getActiveElement(getOwnerDocument(inputRef.current)) !== inputRef.current) {\n      inputRef.current.focus();\n    }\n\n    let target = e.target as Element | null;\n    if (e.isTrusted || !target || queuedActiveDescendant.current === target.id) {\n      return;\n    }\n\n    clearTimeout(timeout.current);\n    if (target !== collectionRef.current) {\n      if (delayNextActiveDescendant.current) {\n        queuedActiveDescendant.current = target.id;\n        timeout.current = setTimeout(() => {\n          state.setFocusedNodeId(target.id);\n        }, 500);\n      } else {\n        queuedActiveDescendant.current = target.id;\n        state.setFocusedNodeId(target.id);\n      }\n    } else if (queuedActiveDescendant.current && !document.getElementById(queuedActiveDescendant.current)) {\n      // If we recieve a focus event refocusing the collection, either we have newly refocused the input and are waiting for the\n      // wrapped collection to refocus the previously focused node if any OR\n      // we are in a state where we've filtered to such a point that there aren't any matching items in the collection to focus.\n      // In this case we want to clear tracked item if any and clear active descendant\n      queuedActiveDescendant.current = null;\n      state.setFocusedNodeId(null);\n    }\n\n    delayNextActiveDescendant.current = false;\n  });\n\n  let callbackRef = useCallback((collectionNode) => {\n    if (collectionNode != null) {\n      // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement\n      // of the letter you just typed. If we recieve another focus event then we clear the queued update\n      // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles\n      // React 19's extra call of the callback ref in strict mode\n      lastCollectionNode.current?.removeEventListener('focusin', updateActiveDescendant);\n      lastCollectionNode.current = collectionNode;\n      collectionNode.addEventListener('focusin', updateActiveDescendant);\n      // If useSelectableCollection isn't passed shouldUseVirtualFocus even when useAutocomplete provides it\n      // that means the collection doesn't support it (e.g. Table). If that is the case, we need to disable it here regardless\n      // of what the user's provided so that the input doesn't recieve the onKeyDown and autocomplete props.\n      if (collectionNode.getAttribute('tabindex') != null) {\n        setShouldUseVirtualFocus(false);\n      }\n      setHasCollection(true);\n    } else {\n      lastCollectionNode.current?.removeEventListener('focusin', updateActiveDescendant);\n      setHasCollection(false);\n    }\n  }, [updateActiveDescendant]);\n\n  // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection\n  let mergedCollectionRef = useObjectRef(useMemo(() => mergeRefs(collectionRef, callbackRef), [collectionRef, callbackRef]));\n\n  let focusFirstItem = useEffectEvent(() => {\n    delayNextActiveDescendant.current = true;\n    collectionRef.current?.dispatchEvent(\n      new CustomEvent(FOCUS_EVENT, {\n        cancelable: true,\n        bubbles: true,\n        detail: {\n          focusStrategy: 'first'\n        }\n      })\n    );\n  });\n\n  let clearVirtualFocus = useEffectEvent((clearFocusKey?: boolean) => {\n    moveVirtualFocus(getActiveElement());\n    queuedActiveDescendant.current = null;\n    state.setFocusedNodeId(null);\n    let clearFocusEvent = new CustomEvent(CLEAR_FOCUS_EVENT, {\n      cancelable: true,\n      bubbles: true,\n      detail: {\n        clearFocusKey\n      }\n    });\n    clearTimeout(timeout.current);\n    delayNextActiveDescendant.current = false;\n    collectionRef.current?.dispatchEvent(clearFocusEvent);\n  });\n\n  let lastInputType = useRef('');\n  useEvent(inputRef, 'input', e => {\n    let {inputType} = e as InputEvent;\n    lastInputType.current = inputType;\n  });\n\n  let onChange = (value: string) => {\n    // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when modifying the text via\n    // copy paste/backspacing/undo/redo for screen reader announcements\n    if (lastInputType.current === 'insertText' && !disableAutoFocusFirst) {\n      focusFirstItem();\n    } else if (lastInputType.current && (lastInputType.current.includes('insert') || lastInputType.current.includes('delete') || lastInputType.current.includes('history'))) {\n      clearVirtualFocus(true);\n\n      // If onChange was triggered before the timeout actually updated the activedescendant, we need to fire\n      // our own dispatchVirtualFocus so focusVisible gets reapplied on the input\n      if (getVirtuallyFocusedElement(document) === inputRef.current) {\n        dispatchVirtualFocus(inputRef.current!, null);\n      }\n    }\n\n    state.setInputValue(value);\n  };\n\n  let keyDownTarget = useRef<Element | null>(null);\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<ReactKeyboardEvent<any>>) => {\n    keyDownTarget.current = e.target as Element;\n    if (e.nativeEvent.isComposing) {\n      return;\n    }\n\n    let focusedNodeId = queuedActiveDescendant.current;\n    switch (e.key) {\n      case 'a':\n        if (isCtrlKeyPressed(e)) {\n          return;\n        }\n        break;\n      case 'Escape':\n        // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and\n        // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check\n        // for isPropagationStopped\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        break;\n      case ' ':\n        // Space shouldn't trigger onAction so early return.\n        return;\n      case 'Tab':\n        // Don't propogate Tab down to the collection, otherwise we will try to focus the collection via useSelectableCollection's Tab handler (aka shift tab logic)\n        // We want FocusScope to handle Tab if one exists (aka sub dialog), so special casepropogate\n        if ('continuePropagation' in e) {\n          e.continuePropagation();\n        }\n        return;\n      case 'Home':\n      case 'End':\n      case 'PageDown':\n      case 'PageUp':\n      case 'ArrowUp':\n      case 'ArrowDown': {\n        if ((e.key === 'Home' || e.key === 'End') && focusedNodeId == null && e.shiftKey) {\n          return;\n        }\n\n        // Prevent these keys from moving the text cursor in the input\n        e.preventDefault();\n        // Move virtual focus into the wrapped collection\n        let focusCollection = new CustomEvent(FOCUS_EVENT, {\n          cancelable: true,\n          bubbles: true\n        });\n\n        collectionRef.current?.dispatchEvent(focusCollection);\n        break;\n      }\n    }\n\n    // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter\n    // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events\n    // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble\n    // as expected\n    if (!e.isPropagationStopped()) {\n      e.stopPropagation();\n    }\n\n    let shouldPerformDefaultAction = true;\n    if (collectionRef.current !== null) {\n      if (focusedNodeId == null) {\n        shouldPerformDefaultAction = collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n        ) || false;\n      } else {\n        let item = document.getElementById(focusedNodeId);\n        if (item) {\n          shouldPerformDefaultAction = item?.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          ) || false;\n        }\n      }\n    }\n\n    if (shouldPerformDefaultAction) {\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowRight': {\n          // Clear the activedescendant so NVDA announcements aren't interrupted but retain the focused key in the collection so the\n          // user's keyboard navigation restarts from where they left off\n          clearVirtualFocus();\n          break;\n        }\n        case 'Enter':\n          // Trigger click action on item when Enter key was pressed.\n          if (focusedNodeId != null) {\n            let item = document.getElementById(focusedNodeId);\n            item?.click();\n          }\n          break;\n      }\n    } else {\n      // TODO: check if we can do this, want to stop textArea from using its default Enter behavior so items are properly triggered\n      e.preventDefault();\n    }\n  };\n\n  let onKeyUpCapture = useEffectEvent((e) => {\n    // Dispatch simulated key up events for things like triggering links in listbox\n    // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair\n    // is detected by usePress instead of the original keyup originating from the input\n    if (e.target === keyDownTarget.current) {\n      e.stopImmediatePropagation();\n      let focusedNodeId = queuedActiveDescendant.current;\n      if (focusedNodeId == null) {\n        collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      } else {\n        let item = document.getElementById(focusedNodeId);\n        item?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      }\n    }\n  });\n\n  useEffect(() => {\n    document.addEventListener('keyup', onKeyUpCapture, true);\n    return () => {\n      document.removeEventListener('keyup', onKeyUpCapture, true);\n    };\n  }, [onKeyUpCapture]);\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/autocomplete');\n  let collectionProps = useLabels({\n    id: collectionId,\n    'aria-label': stringFormatter.format('collectionLabel')\n  });\n\n  let filterFn = useCallback((nodeTextValue: string, node: Node<T>) => {\n    if (filter) {\n      return filter(nodeTextValue, state.inputValue, node);\n    }\n\n    return true;\n  }, [state.inputValue, filter]);\n\n  // Be sure to clear/restore the virtual + collection focus when blurring/refocusing the field so we only show the\n  // focus ring on the virtually focused collection when are actually interacting with the Autocomplete\n  let onBlur = (e: ReactFocusEvent) => {\n    if (!e.isTrusted) {\n      return;\n    }\n\n    let lastFocusedNode = queuedActiveDescendant.current ? document.getElementById(queuedActiveDescendant.current) : null;\n    if (lastFocusedNode) {\n      dispatchVirtualBlur(lastFocusedNode, e.relatedTarget);\n    }\n  };\n\n  let onFocus = (e: ReactFocusEvent) => {\n    if (!e.isTrusted) {\n      return;\n    }\n\n    let curFocusedNode = queuedActiveDescendant.current ? document.getElementById(queuedActiveDescendant.current) : null;\n    if (curFocusedNode) {\n      let target = e.target;\n      queueMicrotask(() => {\n        // instead of focusing the last focused node, just focus the collection instead and have the collection handle what item to focus via useSelectableCollection/Item\n        dispatchVirtualBlur(target, collectionRef.current);\n        dispatchVirtualFocus(collectionRef.current!, target);\n      });\n    }\n  };\n\n  // Only apply the autocomplete specific behaviors if the collection component wrapped by it is actually\n  // being filtered/allows filtering by the Autocomplete.\n  let inputProps = {\n    value: state.inputValue,\n    onChange\n  } as AriaTextFieldProps<FocusableElement>;\n\n  let virtualFocusProps = {\n    onKeyDown,\n    'aria-activedescendant': state.focusedNodeId ?? undefined,\n    onBlur,\n    onFocus\n  };\n\n  if (hasCollection) {\n    inputProps = {\n      ...inputProps,\n      ...(shouldUseVirtualFocus && virtualFocusProps),\n      enterKeyHint: 'go',\n      'aria-controls': collectionId,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false',\n      autoComplete: 'off'\n    };\n  }\n\n  return {\n    inputProps,\n    collectionProps: mergeProps(collectionProps, {\n      shouldUseVirtualFocus,\n      disallowTypeAhead: shouldUseVirtualFocus\n    }),\n    collectionRef: mergedCollectionRef,\n    filter: filter != null ? filterFn : undefined\n  };\n}\n"],"names":[],"version":3,"file":"useAutocomplete.module.js.map"}