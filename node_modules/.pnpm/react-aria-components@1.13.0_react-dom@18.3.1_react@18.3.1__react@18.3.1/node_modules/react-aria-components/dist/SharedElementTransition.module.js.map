{"mappings":"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","sources":["packages/react-aria-components/src/SharedElementTransition.tsx"],"sourcesContent":["/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {flushSync} from 'react-dom';\nimport React, {createContext, ForwardedRef, forwardRef, HTMLAttributes, ReactNode, RefObject, useContext, useRef, useState} from 'react';\nimport {RenderProps, useRenderProps} from './utils';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {useObjectRef} from 'react-aria';\n\ninterface Snapshot {\n  rect: DOMRect,\n  style: [string, string][]\n}\n\nconst SharedElementContext = createContext<RefObject<{[name: string]: Snapshot}> | null>(null);\n\nexport interface SharedElementTransitionProps {\n  children: ReactNode\n}\n\n/**\n * A scope for SharedElements, which animate between parents.\n */\nexport function SharedElementTransition(props: SharedElementTransitionProps) {\n  let ref = useRef({});\n  return (\n    <SharedElementContext.Provider value={ref}>\n      {props.children}\n    </SharedElementContext.Provider>\n  );\n}\n\nexport interface SharedElementRenderProps {\n  /**\n   * Whether the element is currently entering.\n   * @selector [data-entering]\n   */\n  isEntering: boolean,\n  /**\n   * Whether the element is currently exiting.\n   * @selector [data-exiting]\n   */\n  isExiting: boolean\n}\n\nexport interface SharedElementPropsBase extends Omit<HTMLAttributes<HTMLDivElement>, 'children' | 'className' | 'style'>, RenderProps<SharedElementRenderProps> {}\n\nexport interface SharedElementProps extends SharedElementPropsBase {\n  name: string,\n  isVisible?: boolean\n}\n\n/**\n * An element that animates between its old and new position when moving between parents.\n */\nexport const SharedElement = forwardRef(function SharedElement(props: SharedElementProps, ref: ForwardedRef<HTMLDivElement>) {\n  let {name, isVisible = true, children, className, style, ...divProps} = props;\n  let [state, setState] = useState(isVisible ? 'visible' : 'hidden');\n  let scopeRef = useContext(SharedElementContext);\n  if (!scopeRef) {\n    throw new Error('<SharedElement> must be rendered inside a <SharedElementTransition>');\n  }\n\n  if (isVisible && state === 'hidden') {\n    setState('visible');\n  }\n\n  ref = useObjectRef(ref);\n  useLayoutEffect(() => {\n    let element = ref.current;\n    let scope = scopeRef.current;\n    let prevSnapshot = scope[name];\n    let frame: number | null = null;\n\n    if (element && isVisible && prevSnapshot) {\n      // Element is transitioning from a previous instance.\n      setState('visible');\n      let animations = element.getAnimations();\n\n      // Set properties to animate from.\n      let values = prevSnapshot.style.map(([property, prevValue]) => {\n        let value = element.style[property];\n        if (property === 'translate') {\n          let prevRect = prevSnapshot.rect;\n          let currentItem = element.getBoundingClientRect();\n          let deltaX = prevRect.left - currentItem?.left;\n          let deltaY = prevRect.top - currentItem?.top;\n          element.style.translate = `${deltaX}px ${deltaY}px`;\n        } else {\n          element.style[property] = prevValue;\n        }\n        return [property, value];\n      });\n\n      // Cancel any new animations triggered by these properties.\n      for (let a of element.getAnimations()) {\n        if (!animations.includes(a)) {\n          a.cancel();\n        }\n      }\n\n      // Remove overrides after one frame to animate to the current values.\n      frame = requestAnimationFrame(() => {\n        frame = null;\n        for (let [property, value] of values) {\n          element.style[property] = value;\n        }\n      });\n\n      delete scope[name];\n    } else if (element && isVisible && !prevSnapshot) {\n      // No previous instance exists, apply the entering state.\n      queueMicrotask(() => flushSync(() => setState('entering')));\n      frame = requestAnimationFrame(() => {\n        frame = null;\n        setState('visible');\n      });\n    } else if (element && !isVisible) {\n      // Wait until layout effects finish, and check if a snapshot still exists.\n      // If so, no new SharedElement consumed it, so enter the exiting state.\n      queueMicrotask(() => {\n        if (scope[name]) {\n          delete scope[name];\n          flushSync(() => setState('exiting'));\n          Promise.all(element.getAnimations().map(a => a.finished))\n            .then(() => setState('hidden'))\n            .catch(() => {});\n        } else {\n          // Snapshot was consumed by another instance, unmount.\n          setState('hidden');\n        }\n      });\n    }\n\n    return () => {\n      if (frame != null) {\n        cancelAnimationFrame(frame);\n      }\n\n      if (element && element.isConnected && !element.hasAttribute('data-exiting')) {\n        // On unmount, store a snapshot of the rectangle and computed style for transitioning properties.\n        let style = window.getComputedStyle(element);\n        if (style.transitionProperty !== 'none') {\n          let transitionProperty = style.transitionProperty.split(/\\s*,\\s*/);\n          scope[name] = {\n            rect: element.getBoundingClientRect(),\n            style: transitionProperty.map(p => [p, style[p]])\n          };\n        }\n      }\n    };\n  }, [ref, scopeRef, name, isVisible]);\n\n  let renderProps = useRenderProps({\n    children,\n    className,\n    style,\n    values: {\n      isEntering: state === 'entering',\n      isExiting: state === 'exiting'\n    }\n  });\n\n  if (state === 'hidden') {\n    return null;\n  }\n\n  return (\n    <div\n      {...divProps}\n      {...renderProps}\n      ref={ref}\n      data-entering={state === 'entering' || undefined}\n      data-exiting={state === 'exiting' || undefined} />\n  );\n});\n"],"names":[],"version":3,"file":"SharedElementTransition.module.js.map"}