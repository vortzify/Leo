import {ButtonContext as $d2b4bc8c273e7be6$export$24d547caef80ccd1} from "./Button.mjs";
import {CheckboxContext as $4e85f108e88277b8$export$b085522c77523c51} from "./RSPContexts.mjs";
import {DEFAULT_SLOT as $64fa3d84918910a7$export$c62b8e45d58ddad9, Provider as $64fa3d84918910a7$export$2881499e37b75b9a, useContextProps as $64fa3d84918910a7$export$29f1550f4b0d4415, useRenderProps as $64fa3d84918910a7$export$4d86445c2cf5e3} from "./utils.mjs";
import {CollectionRendererContext as $7135fc7d473fd974$export$4feb769f8ddf26c5, DefaultCollectionRenderer as $7135fc7d473fd974$export$a164736487e3f0ae} from "./Collection.mjs";
import {DragAndDropContext as $612b8eb6cb90e02d$export$d188a835a7bc5783, DropIndicatorContext as $612b8eb6cb90e02d$export$f55761759794cf55, useDndPersistedKeys as $612b8eb6cb90e02d$export$d1e8e3fbb7461f6, useRenderDropIndicator as $612b8eb6cb90e02d$export$971707d8a129a1f7} from "./DragAndDrop.mjs";
import {SelectionIndicatorContext as $1d5b8b8664671ef2$export$c9549807523555e0} from "./SelectionIndicator.mjs";
import {SharedElementTransition as $c8a5a149f625efcf$export$758399f318e6385a} from "./SharedElementTransition.mjs";
import {TreeDropTargetDelegate as $7e0f784ed4e400df$export$82c13862611c034e} from "./TreeDropTargetDelegate.mjs";
import {useLocale as $kUtXx$useLocale, useCollator as $kUtXx$useCollator, useTree as $kUtXx$useTree, ListKeyboardDelegate as $kUtXx$ListKeyboardDelegate, useFocusRing as $kUtXx$useFocusRing, FocusScope as $kUtXx$FocusScope, mergeProps as $kUtXx$mergeProps, useTreeItem as $kUtXx$useTreeItem, useHover as $kUtXx$useHover, useGridListSelectionCheckbox as $kUtXx$useGridListSelectionCheckbox, useVisuallyHidden as $kUtXx$useVisuallyHidden, useId as $kUtXx$useId} from "react-aria";
import {CollectionBuilder as $kUtXx$CollectionBuilder, Collection as $kUtXx$Collection, CollectionNode as $kUtXx$CollectionNode, createLeafComponent as $kUtXx$createLeafComponent, createBranchComponent as $kUtXx$createBranchComponent, useCachedChildren as $kUtXx$useCachedChildren, LoaderNode as $kUtXx$LoaderNode} from "@react-aria/collections";
import {useTreeState as $kUtXx$useTreeState} from "react-stately";
import {filterDOMProps as $kUtXx$filterDOMProps, useObjectRef as $kUtXx$useObjectRef, useLoadMoreSentinel as $kUtXx$useLoadMoreSentinel, inertValue as $kUtXx$inertValue} from "@react-aria/utils";
import $kUtXx$react, {createContext as $kUtXx$createContext, forwardRef as $kUtXx$forwardRef, useRef as $kUtXx$useRef, useEffect as $kUtXx$useEffect, useContext as $kUtXx$useContext, useMemo as $kUtXx$useMemo, useState as $kUtXx$useState} from "react";
import {useControlledState as $kUtXx$useControlledState} from "@react-stately/utils";

/*
 * Copyright 2024 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 













class $2f5eaf4a2a47b4cf$var$TreeCollection {
    // TODO: should this collection's getters reflect the flattened structure or the original structure
    // If we respresent the flattened structure, it is easier for the keyboard nav but harder to find all the nodes
    *[Symbol.iterator]() {
        yield* this.flattenedRows;
    }
    get size() {
        return this.itemCount;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getItem(key) {
        return this.keyMap.get(key) || null;
    }
    at(idx) {
        return this.flattenedRows[idx];
    }
    getFirstKey() {
        var _this_flattenedRows_;
        return (_this_flattenedRows_ = this.flattenedRows[0]) === null || _this_flattenedRows_ === void 0 ? void 0 : _this_flattenedRows_.key;
    }
    getLastKey() {
        var _this_flattenedRows_;
        return (_this_flattenedRows_ = this.flattenedRows[this.flattenedRows.length - 1]) === null || _this_flattenedRows_ === void 0 ? void 0 : _this_flattenedRows_.key;
    }
    getKeyAfter(key) {
        var _this_flattenedRows_;
        let index = this.flattenedRows.findIndex((row)=>row.key === key);
        return (_this_flattenedRows_ = this.flattenedRows[index + 1]) === null || _this_flattenedRows_ === void 0 ? void 0 : _this_flattenedRows_.key;
    }
    getKeyBefore(key) {
        var _this_flattenedRows_;
        let index = this.flattenedRows.findIndex((row)=>row.key === key);
        return (_this_flattenedRows_ = this.flattenedRows[index - 1]) === null || _this_flattenedRows_ === void 0 ? void 0 : _this_flattenedRows_.key;
    }
    // Note that this will return Content nodes in addition to nested TreeItems
    getChildren(key) {
        let keyMap = this.keyMap;
        return {
            *[Symbol.iterator] () {
                let parent = keyMap.get(key);
                let node = (parent === null || parent === void 0 ? void 0 : parent.firstChildKey) != null ? keyMap.get(parent.firstChildKey) : null;
                while(node){
                    yield node;
                    node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;
                }
            }
        };
    }
    getTextValue(key) {
        let item = this.getItem(key);
        return item ? item.textValue : '';
    }
    constructor(opts){
        this.keyMap = new Map();
        this.itemCount = 0;
        let { collection: collection, expandedKeys: expandedKeys } = opts;
        let { flattenedRows: flattenedRows, keyMap: keyMap, itemCount: itemCount } = $2f5eaf4a2a47b4cf$var$flattenTree(collection, {
            expandedKeys: expandedKeys
        });
        this.flattenedRows = flattenedRows;
        // Use generated keyMap because it contains the modified collection nodes (aka it adjusts the indexes so that they ignore the existence of the Content items)
        this.keyMap = keyMap;
        this.itemCount = itemCount;
    }
}
const $2f5eaf4a2a47b4cf$export$dfae7d399eea2568 = /*#__PURE__*/ (0, $kUtXx$createContext)(null);
const $2f5eaf4a2a47b4cf$export$8953bccafd7bce87 = /*#__PURE__*/ (0, $kUtXx$createContext)(null);
const $2f5eaf4a2a47b4cf$export$7fbedc92909ed28e = /*#__PURE__*/ (0, $kUtXx$forwardRef)(function Tree(props, ref) {
    // Render the portal first so that we have the collection by the time we render the DOM in SSR.
    [props, ref] = (0, $64fa3d84918910a7$export$29f1550f4b0d4415)(props, ref, $2f5eaf4a2a47b4cf$export$dfae7d399eea2568);
    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$CollectionBuilder), {
        content: /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$Collection), props)
    }, (collection)=>/*#__PURE__*/ (0, $kUtXx$react).createElement($2f5eaf4a2a47b4cf$var$TreeInner, {
            props: props,
            collection: collection,
            treeRef: ref
        }));
});
const $2f5eaf4a2a47b4cf$var$EXPANSION_KEYS = {
    'expand': {
        ltr: 'ArrowRight',
        rtl: 'ArrowLeft'
    },
    'collapse': {
        ltr: 'ArrowLeft',
        rtl: 'ArrowRight'
    }
};
function $2f5eaf4a2a47b4cf$var$TreeInner({ props: props, collection: collection, treeRef: ref }) {
    const { dragAndDropHooks: dragAndDropHooks } = props;
    let { direction: direction } = (0, $kUtXx$useLocale)();
    let collator = (0, $kUtXx$useCollator)({
        usage: 'search',
        sensitivity: 'base'
    });
    let hasDragHooks = !!(dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.useDraggableCollectionState);
    let hasDropHooks = !!(dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.useDroppableCollectionState);
    let dragHooksProvided = (0, $kUtXx$useRef)(hasDragHooks);
    let dropHooksProvided = (0, $kUtXx$useRef)(hasDropHooks);
    (0, $kUtXx$useEffect)(()=>{
        if (dragHooksProvided.current !== hasDragHooks) console.warn('Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.');
        if (dropHooksProvided.current !== hasDropHooks) console.warn('Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.');
    }, [
        hasDragHooks,
        hasDropHooks
    ]);
    let { selectionMode: selectionMode = 'none', expandedKeys: propExpandedKeys, defaultExpandedKeys: propDefaultExpandedKeys, onExpandedChange: onExpandedChange, disabledBehavior: disabledBehavior = 'all' } = props;
    let { CollectionRoot: CollectionRoot, isVirtualized: isVirtualized, layoutDelegate: layoutDelegate, dropTargetDelegate: ctxDropTargetDelegate } = (0, $kUtXx$useContext)((0, $7135fc7d473fd974$export$4feb769f8ddf26c5));
    // Kinda annoying that we have to replicate this code here as well as in useTreeState, but don't want to add
    // flattenCollection stuff to useTreeState. Think about this later
    let [expandedKeys, setExpandedKeys] = (0, $kUtXx$useControlledState)(propExpandedKeys ? $2f5eaf4a2a47b4cf$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $2f5eaf4a2a47b4cf$var$convertExpanded(propDefaultExpandedKeys) : new Set(), onExpandedChange);
    let flattenedCollection = (0, $kUtXx$useMemo)(()=>{
        return new $2f5eaf4a2a47b4cf$var$TreeCollection({
            collection: collection,
            expandedKeys: expandedKeys
        });
    }, [
        collection,
        expandedKeys
    ]);
    let state = (0, $kUtXx$useTreeState)({
        ...props,
        selectionMode: selectionMode,
        expandedKeys: expandedKeys,
        onExpandedChange: setExpandedKeys,
        collection: flattenedCollection,
        children: undefined,
        disabledBehavior: disabledBehavior
    });
    let { gridProps: gridProps } = (0, $kUtXx$useTree)({
        ...props,
        isVirtualized: isVirtualized,
        layoutDelegate: layoutDelegate
    }, state, ref);
    let dragState = undefined;
    let dropState = undefined;
    let droppableCollection = undefined;
    let isRootDropTarget = false;
    let dragPreview = null;
    let preview = (0, $kUtXx$useRef)(null);
    if (hasDragHooks && dragAndDropHooks) {
        dragState = dragAndDropHooks.useDraggableCollectionState({
            collection: state.collection,
            selectionManager: state.selectionManager,
            preview: dragAndDropHooks.renderDragPreview ? preview : undefined
        });
        dragAndDropHooks.useDraggableCollection({}, dragState, ref);
        let DragPreview = dragAndDropHooks.DragPreview;
        dragPreview = dragAndDropHooks.renderDragPreview ? /*#__PURE__*/ (0, $kUtXx$react).createElement(DragPreview, {
            ref: preview
        }, dragAndDropHooks.renderDragPreview) : null;
    }
    let [treeDropTargetDelegate] = (0, $kUtXx$useState)(()=>new (0, $7e0f784ed4e400df$export$82c13862611c034e)());
    if (hasDropHooks && dragAndDropHooks) {
        dropState = dragAndDropHooks.useDroppableCollectionState({
            collection: state.collection,
            selectionManager: state.selectionManager
        });
        let dropTargetDelegate = dragAndDropHooks.dropTargetDelegate || ctxDropTargetDelegate || new dragAndDropHooks.ListDropTargetDelegate(state.collection, ref, {
            direction: direction
        });
        treeDropTargetDelegate.setup(dropTargetDelegate, state, direction);
        let keyboardDelegate = new (0, $kUtXx$ListKeyboardDelegate)({
            collection: state.collection,
            collator: collator,
            ref: ref,
            disabledKeys: state.selectionManager.disabledKeys,
            disabledBehavior: state.selectionManager.disabledBehavior,
            direction: direction,
            layoutDelegate: layoutDelegate
        });
        droppableCollection = dragAndDropHooks.useDroppableCollection({
            keyboardDelegate: keyboardDelegate,
            dropTargetDelegate: treeDropTargetDelegate,
            onDropActivate: (e)=>{
                // Expand collapsed item when dragging over. For keyboard, allow collapsing.
                if (e.target.type === 'item') {
                    var _dragAndDropHooks_isVirtualDragging;
                    let key = e.target.key;
                    let item = state.collection.getItem(key);
                    let isExpanded = expandedKeys !== 'all' && expandedKeys.has(key);
                    if (item && item.hasChildNodes && (!isExpanded || (dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : (_dragAndDropHooks_isVirtualDragging = dragAndDropHooks.isVirtualDragging) === null || _dragAndDropHooks_isVirtualDragging === void 0 ? void 0 : _dragAndDropHooks_isVirtualDragging.call(dragAndDropHooks)))) state.toggleKey(key);
                }
            },
            onKeyDown: (e)=>{
                let target = dropState === null || dropState === void 0 ? void 0 : dropState.target;
                if (target && target.type === 'item' && target.dropPosition === 'on') {
                    let item = state.collection.getItem(target.key);
                    if (e.key === $2f5eaf4a2a47b4cf$var$EXPANSION_KEYS['expand'][direction] && (item === null || item === void 0 ? void 0 : item.hasChildNodes) && !state.expandedKeys.has(target.key)) state.toggleKey(target.key);
                    else if (e.key === $2f5eaf4a2a47b4cf$var$EXPANSION_KEYS['collapse'][direction] && (item === null || item === void 0 ? void 0 : item.hasChildNodes) && state.expandedKeys.has(target.key)) state.toggleKey(target.key);
                }
            }
        }, dropState, ref);
        // Prevent dropping items onto themselves or their descendants
        let originalGetDropOperation = dropState.getDropOperation;
        dropState.getDropOperation = (options)=>{
            let { target: target, isInternal: isInternal } = options;
            var _dragState_draggingKeys;
            let currentDraggingKeys = (_dragState_draggingKeys = dragState === null || dragState === void 0 ? void 0 : dragState.draggingKeys) !== null && _dragState_draggingKeys !== void 0 ? _dragState_draggingKeys : new Set();
            if (isInternal && target.type === 'item' && currentDraggingKeys.size > 0) {
                if (currentDraggingKeys.has(target.key) && target.dropPosition === 'on') return 'cancel';
                let currentKey = target.key;
                while(currentKey != null){
                    let item = state.collection.getItem(currentKey);
                    let parentKey = item === null || item === void 0 ? void 0 : item.parentKey;
                    if (parentKey != null && currentDraggingKeys.has(parentKey)) return 'cancel';
                    currentKey = parentKey !== null && parentKey !== void 0 ? parentKey : null;
                }
            }
            return originalGetDropOperation(options);
        };
        isRootDropTarget = dropState.isDropTarget({
            type: 'root'
        });
    }
    let isTreeDraggable = !!(hasDragHooks && !(dragState === null || dragState === void 0 ? void 0 : dragState.isDisabled));
    let { focusProps: focusProps, isFocused: isFocused, isFocusVisible: isFocusVisible } = (0, $kUtXx$useFocusRing)();
    let renderValues = {
        isEmpty: state.collection.size === 0,
        isFocused: isFocused,
        isFocusVisible: isFocusVisible,
        isDropTarget: isRootDropTarget,
        selectionMode: state.selectionManager.selectionMode,
        allowsDragging: !!isTreeDraggable,
        state: state
    };
    let renderProps = (0, $64fa3d84918910a7$export$4d86445c2cf5e3)({
        className: props.className,
        style: props.style,
        defaultClassName: 'react-aria-Tree',
        values: renderValues
    });
    let emptyState = null;
    if (state.collection.size === 0 && props.renderEmptyState) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        let { isEmpty: isEmpty, ...values } = renderValues;
        let content = props.renderEmptyState({
            ...values
        });
        let treeGridRowProps = {
            'aria-level': 1
        };
        emptyState = /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
            role: "row",
            style: {
                display: 'contents'
            },
            ...treeGridRowProps
        }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
            role: "gridcell",
            style: {
                display: 'contents'
            }
        }, content));
    }
    let DOMProps = (0, $kUtXx$filterDOMProps)(props, {
        global: true
    });
    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$react).Fragment, null, /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$FocusScope), null, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...(0, $kUtXx$mergeProps)(DOMProps, renderProps, gridProps, focusProps, droppableCollection === null || droppableCollection === void 0 ? void 0 : droppableCollection.collectionProps),
        ref: ref,
        slot: props.slot || undefined,
        "data-empty": state.collection.size === 0 || undefined,
        "data-focused": isFocused || undefined,
        "data-drop-target": isRootDropTarget || undefined,
        "data-focus-visible": isFocusVisible || undefined,
        "data-selection-mode": state.selectionManager.selectionMode === 'none' ? undefined : state.selectionManager.selectionMode,
        "data-allows-dragging": !!isTreeDraggable || undefined
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $64fa3d84918910a7$export$2881499e37b75b9a), {
        values: [
            [
                $2f5eaf4a2a47b4cf$export$8953bccafd7bce87,
                state
            ],
            [
                (0, $612b8eb6cb90e02d$export$d188a835a7bc5783),
                {
                    dragAndDropHooks: dragAndDropHooks,
                    dragState: dragState,
                    dropState: dropState
                }
            ],
            [
                (0, $612b8eb6cb90e02d$export$f55761759794cf55),
                {
                    render: $2f5eaf4a2a47b4cf$var$TreeDropIndicatorWrapper
                }
            ]
        ]
    }, hasDropHooks && /*#__PURE__*/ (0, $kUtXx$react).createElement($2f5eaf4a2a47b4cf$var$RootDropIndicator, null), /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $c8a5a149f625efcf$export$758399f318e6385a), null, /*#__PURE__*/ (0, $kUtXx$react).createElement(CollectionRoot, {
        collection: state.collection,
        persistedKeys: (0, $612b8eb6cb90e02d$export$d1e8e3fbb7461f6)(state.selectionManager, dragAndDropHooks, dropState),
        scrollRef: ref,
        renderDropIndicator: (0, $612b8eb6cb90e02d$export$971707d8a129a1f7)(dragAndDropHooks, dropState)
    }))), emptyState)), dragPreview);
}
class $2f5eaf4a2a47b4cf$var$TreeContentNode extends (0, $kUtXx$CollectionNode) {
}
$2f5eaf4a2a47b4cf$var$TreeContentNode.type = 'content';
const $2f5eaf4a2a47b4cf$export$4b687e3f663d618c = /*#__PURE__*/ (0, $kUtXx$createLeafComponent)($2f5eaf4a2a47b4cf$var$TreeContentNode, function TreeItemContent(props) {
    let values = (0, $kUtXx$useContext)($2f5eaf4a2a47b4cf$export$36b5dda0d9bc8f78);
    let renderProps = (0, $64fa3d84918910a7$export$4d86445c2cf5e3)({
        children: props.children,
        values: values
    });
    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $7135fc7d473fd974$export$4feb769f8ddf26c5).Provider, {
        value: (0, $7135fc7d473fd974$export$a164736487e3f0ae)
    }, renderProps.children);
});
const $2f5eaf4a2a47b4cf$export$36b5dda0d9bc8f78 = /*#__PURE__*/ (0, $kUtXx$createContext)(null);
class $2f5eaf4a2a47b4cf$var$TreeItemNode extends (0, $kUtXx$CollectionNode) {
}
$2f5eaf4a2a47b4cf$var$TreeItemNode.type = 'item';
const $2f5eaf4a2a47b4cf$export$53d36ab85dc89436 = /*#__PURE__*/ (0, $kUtXx$createBranchComponent)($2f5eaf4a2a47b4cf$var$TreeItemNode, (props, ref, item)=>{
    var _this;
    let state = (0, $kUtXx$useContext)($2f5eaf4a2a47b4cf$export$8953bccafd7bce87);
    ref = (0, $kUtXx$useObjectRef)(ref);
    let { dragAndDropHooks: dragAndDropHooks, dragState: dragState, dropState: dropState } = (0, $kUtXx$useContext)((0, $612b8eb6cb90e02d$export$d188a835a7bc5783));
    // TODO: remove this when we support description in tree row
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { rowProps: rowProps, gridCellProps: gridCellProps, expandButtonProps: expandButtonProps, descriptionProps: descriptionProps, ...states } = (0, $kUtXx$useTreeItem)({
        node: item,
        shouldSelectOnPressUp: !!dragState
    }, state, ref);
    let isExpanded = rowProps['aria-expanded'] === true;
    let hasChildItems = props.hasChildItems || ((_this = [
        ...state.collection.getChildren(item.key)
    ]) === null || _this === void 0 ? void 0 : _this.length) > 1;
    let level = rowProps['aria-level'] || 1;
    let { hoverProps: hoverProps, isHovered: isHovered } = (0, $kUtXx$useHover)({
        isDisabled: !states.allowsSelection && !states.hasAction,
        onHoverStart: props.onHoverStart,
        onHoverChange: props.onHoverChange,
        onHoverEnd: props.onHoverEnd
    });
    let { isFocusVisible: isFocusVisible, focusProps: focusProps } = (0, $kUtXx$useFocusRing)();
    let { isFocusVisible: isFocusVisibleWithin, focusProps: focusWithinProps } = (0, $kUtXx$useFocusRing)({
        within: true
    });
    let { checkboxProps: checkboxProps } = (0, $kUtXx$useGridListSelectionCheckbox)({
        key: item.key
    }, state);
    let draggableItem = null;
    if (dragState && dragAndDropHooks) draggableItem = dragAndDropHooks.useDraggableItem({
        key: item.key,
        hasDragButton: true
    }, dragState);
    let dropIndicator = null;
    let expandButtonRef = (0, $kUtXx$useRef)(null);
    let dropIndicatorRef = (0, $kUtXx$useRef)(null);
    let activateButtonRef = (0, $kUtXx$useRef)(null);
    let { visuallyHiddenProps: visuallyHiddenProps } = (0, $kUtXx$useVisuallyHidden)();
    if (dropState && dragAndDropHooks) dropIndicator = dragAndDropHooks.useDropIndicator({
        target: {
            type: 'item',
            key: item.key,
            dropPosition: 'on'
        },
        activateButtonRef: activateButtonRef
    }, dropState, dropIndicatorRef);
    let isDragging = dragState && dragState.isDragging(item.key);
    let isDropTarget = dropIndicator === null || dropIndicator === void 0 ? void 0 : dropIndicator.isDropTarget;
    let selectionMode = state.selectionManager.selectionMode;
    let selectionBehavior = state.selectionManager.selectionBehavior;
    let renderPropValues = (0, $kUtXx$react).useMemo(()=>({
            ...states,
            isHovered: isHovered,
            isFocusVisible: isFocusVisible,
            isExpanded: isExpanded,
            hasChildItems: hasChildItems,
            level: level,
            selectionMode: selectionMode,
            selectionBehavior: selectionBehavior,
            isFocusVisibleWithin: isFocusVisibleWithin,
            state: state,
            id: item.key,
            allowsDragging: !!dragState,
            isDragging: isDragging,
            isDropTarget: isDropTarget
        }), [
        states,
        isHovered,
        isFocusVisible,
        isExpanded,
        hasChildItems,
        level,
        isFocusVisibleWithin,
        state,
        item.key,
        dragState,
        isDragging,
        isDropTarget,
        selectionBehavior,
        selectionMode
    ]);
    let renderProps = (0, $64fa3d84918910a7$export$4d86445c2cf5e3)({
        ...props,
        id: undefined,
        children: item.rendered,
        defaultClassName: 'react-aria-TreeItem',
        defaultStyle: {
            // @ts-ignore
            '--tree-item-level': level
        },
        values: renderPropValues
    });
    (0, $kUtXx$useEffect)(()=>{
        if (!item.textValue && process.env.NODE_ENV !== 'production') console.warn('A `textValue` prop is required for <TreeItem> elements in order to support accessibility features such as type to select.');
    }, [
        item.textValue
    ]);
    (0, $kUtXx$useEffect)(()=>{
        if (hasChildItems && !expandButtonRef.current && process.env.NODE_ENV !== 'production') console.warn('Expandable tree items must contain a expand button so screen reader users can expand/collapse the item.');
    // eslint-disable-next-line
    }, []);
    let dragButtonRef = (0, $kUtXx$useRef)(null);
    (0, $kUtXx$useEffect)(()=>{
        if (dragState && !dragButtonRef.current && process.env.NODE_ENV !== 'production') console.warn('Draggable items in a Tree must contain a <Button slot="drag"> element so that keyboard and screen reader users can drag them.');
    // eslint-disable-next-line
    }, []);
    let children = (0, $kUtXx$useCachedChildren)({
        items: state.collection.getChildren(item.key),
        children: (item)=>{
            switch(item.type){
                case 'content':
                    return item.render(item);
                // Skip item since we don't render the nested rows as children of the parent row, the flattened collection
                // will render them each as siblings instead
                case 'loader':
                case 'item':
                    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$react).Fragment, null);
                default:
                    throw new Error('Unsupported element type in TreeRow: ' + item.type);
            }
        }
    });
    let activateButtonId = (0, $kUtXx$useId)();
    let DOMProps = (0, $kUtXx$filterDOMProps)(props, {
        global: true
    });
    delete DOMProps.id;
    delete DOMProps.onClick;
    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$react).Fragment, null, dropIndicator && !dropIndicator.isHidden && /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "row",
        "aria-level": rowProps['aria-level'],
        "aria-expanded": rowProps['aria-expanded'],
        "aria-label": dropIndicator.dropIndicatorProps['aria-label']
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "gridcell",
        "aria-colindex": 1,
        style: {
            display: 'contents'
        }
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "button",
        ...visuallyHiddenProps,
        ...dropIndicator.dropIndicatorProps,
        ref: dropIndicatorRef
    }), rowProps['aria-expanded'] != null ? // Button to allow touch screen reader users to expand the item while dragging.
    /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "button",
        ...visuallyHiddenProps,
        id: activateButtonId,
        "aria-label": expandButtonProps['aria-label'],
        "aria-labelledby": `${activateButtonId} ${rowProps.id}`,
        tabIndex: -1,
        ref: activateButtonRef
    }) : null)), /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...(0, $kUtXx$mergeProps)(DOMProps, rowProps, focusProps, hoverProps, focusWithinProps, draggableItem === null || draggableItem === void 0 ? void 0 : draggableItem.dragProps),
        ...renderProps,
        ref: ref,
        // TODO: missing selectionBehavior, hasAction and allowsSelection data attribute equivalents (available in renderProps). Do we want those?
        "data-expanded": hasChildItems && isExpanded || undefined,
        "data-has-child-items": hasChildItems || undefined,
        "data-level": level,
        "data-selected": states.isSelected || undefined,
        "data-disabled": states.isDisabled || undefined,
        "data-hovered": isHovered || undefined,
        "data-focused": states.isFocused || undefined,
        "data-focus-visible": isFocusVisible || undefined,
        "data-pressed": states.isPressed || undefined,
        "data-selection-mode": state.selectionManager.selectionMode === 'none' ? undefined : state.selectionManager.selectionMode,
        "data-allows-dragging": !!dragState || undefined,
        "data-dragging": isDragging || undefined,
        "data-drop-target": isDropTarget || undefined
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...gridCellProps,
        style: {
            display: 'contents'
        }
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $64fa3d84918910a7$export$2881499e37b75b9a), {
        values: [
            [
                (0, $4e85f108e88277b8$export$b085522c77523c51),
                {
                    slots: {
                        selection: checkboxProps
                    }
                }
            ],
            // TODO: support description in the tree row
            // TODO: don't think I need to pass isExpanded to the button here since it can be sourced from the renderProps? Might be worthwhile passing it down?
            [
                (0, $d2b4bc8c273e7be6$export$24d547caef80ccd1),
                {
                    slots: {
                        [(0, $64fa3d84918910a7$export$c62b8e45d58ddad9)]: {},
                        chevron: {
                            ...expandButtonProps,
                            ref: expandButtonRef
                        },
                        drag: {
                            ...draggableItem === null || draggableItem === void 0 ? void 0 : draggableItem.dragButtonProps,
                            ref: dragButtonRef,
                            style: {
                                pointerEvents: 'none'
                            }
                        }
                    }
                }
            ],
            [
                $2f5eaf4a2a47b4cf$export$36b5dda0d9bc8f78,
                {
                    ...renderPropValues
                }
            ],
            [
                (0, $1d5b8b8664671ef2$export$c9549807523555e0),
                {
                    isSelected: states.isSelected
                }
            ]
        ]
    }, children))));
});
const $2f5eaf4a2a47b4cf$export$533df5f8efd48cc9 = (0, $kUtXx$createLeafComponent)((0, $kUtXx$LoaderNode), function TreeLoadingSentinel(props, ref, item) {
    let { isVirtualized: isVirtualized } = (0, $kUtXx$useContext)((0, $7135fc7d473fd974$export$4feb769f8ddf26c5));
    let state = (0, $kUtXx$useContext)($2f5eaf4a2a47b4cf$export$8953bccafd7bce87);
    let { isLoading: isLoading, onLoadMore: onLoadMore, scrollOffset: scrollOffset, ...otherProps } = props;
    let sentinelRef = (0, $kUtXx$useRef)(null);
    let memoedLoadMoreProps = (0, $kUtXx$useMemo)(()=>({
            onLoadMore: onLoadMore,
            // this collection will update anytime a row is expanded/collapsed becaused the flattenedRows will change.
            // This means onLoadMore will trigger but that might be ok cause the user should have logic to handle multiple loadMore calls
            collection: state === null || state === void 0 ? void 0 : state.collection,
            sentinelRef: sentinelRef,
            scrollOffset: scrollOffset
        }), [
        onLoadMore,
        scrollOffset,
        state === null || state === void 0 ? void 0 : state.collection
    ]);
    (0, $kUtXx$useLoadMoreSentinel)(memoedLoadMoreProps, sentinelRef);
    ref = (0, $kUtXx$useObjectRef)(ref);
    let { rowProps: rowProps, gridCellProps: gridCellProps } = (0, $kUtXx$useTreeItem)({
        node: item
    }, state, ref);
    let level = rowProps['aria-level'] || 1;
    // For now don't include aria-posinset and aria-setsize on loader since they aren't keyboard focusable
    // Arguably shouldn't include them ever since it might be confusing to the user to include the loaders as part of the
    // item count
    let ariaProps = {
        role: 'row',
        'aria-level': rowProps['aria-level']
    };
    let renderProps = (0, $64fa3d84918910a7$export$4d86445c2cf5e3)({
        ...otherProps,
        id: undefined,
        children: item.rendered,
        defaultClassName: 'react-aria-TreeLoader',
        values: {
            level: level
        }
    });
    let style = {};
    if (isVirtualized) style = {
        display: 'contents'
    };
    return /*#__PURE__*/ (0, $kUtXx$react).createElement((0, $kUtXx$react).Fragment, null, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        style: {
            position: 'relative',
            width: 0,
            height: 0
        },
        inert: (0, $kUtXx$inertValue)(true)
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        "data-testid": "loadMoreSentinel",
        ref: sentinelRef,
        style: {
            position: 'absolute',
            height: 1,
            width: 1
        }
    })), isLoading && renderProps.children && /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ref: ref,
        ...(0, $kUtXx$mergeProps)((0, $kUtXx$filterDOMProps)(props), ariaProps),
        ...renderProps,
        "data-level": level
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...gridCellProps,
        style: style
    }, renderProps.children)));
});
function $2f5eaf4a2a47b4cf$var$convertExpanded(expanded) {
    if (!expanded) return new Set();
    return expanded === 'all' ? 'all' : new Set(expanded);
}
function $2f5eaf4a2a47b4cf$var$flattenTree(collection, opts) {
    let { expandedKeys: expandedKeys = new Set() } = opts;
    let keyMap = new Map();
    let flattenedRows = [];
    // Need to count the items here because BaseCollection will return the full item count regardless if items are hidden via collapsed rows
    let itemCount = 0;
    let parentLookup = new Map();
    let visitNode = (node)=>{
        if (node.type === 'item' || node.type === 'loader') {
            let parentKey = node === null || node === void 0 ? void 0 : node.parentKey;
            let clone = {
                ...node
            };
            if (parentKey != null) {
                // TODO: assumes that non item content node (aka TreeItemContent always placed before Collection) will be always placed before the child rows. If we can't make this assumption then we can filter out
                // every non-item per level and assign indicies based off the node's position in said filtered array
                let hasContentNode = [
                    ...collection.getChildren(parentKey)
                ][0].type !== 'item';
                if (hasContentNode) clone.index = (node === null || node === void 0 ? void 0 : node.index) != null ? (node === null || node === void 0 ? void 0 : node.index) - 1 : 0;
                // For loader nodes that have a parent (aka non-root level loaders), these need their levels incremented by 1 for parity with their sibiling rows
                // (Collection only increments the level if it is a "item" type node).
                if (node.type === 'loader') clone.level = node.level + 1;
                keyMap.set(clone.key, clone);
            } else keyMap.set(node.key, node);
            // Grab the modified node from the key map so our flattened list and modified key map point to the same nodes
            let modifiedNode = keyMap.get(node.key) || node;
            if (modifiedNode.level === 0 || modifiedNode.parentKey != null && expandedKeys.has(modifiedNode.parentKey) && parentLookup.get(modifiedNode.parentKey)) {
                if (modifiedNode.type === 'item') itemCount++;
                flattenedRows.push(modifiedNode);
                parentLookup.set(modifiedNode.key, true);
            }
        } else if (node.type !== null) keyMap.set(node.key, node);
        for (let child of collection.getChildren(node.key))visitNode(child);
    };
    for (let node of collection)visitNode(node);
    return {
        flattenedRows: flattenedRows,
        keyMap: keyMap,
        itemCount: itemCount
    };
}
function $2f5eaf4a2a47b4cf$var$TreeDropIndicatorWrapper(props, ref) {
    var _dropState_collection_getItem;
    ref = (0, $kUtXx$useObjectRef)(ref);
    let { dragAndDropHooks: dragAndDropHooks, dropState: dropState } = (0, $kUtXx$useContext)((0, $612b8eb6cb90e02d$export$d188a835a7bc5783));
    let buttonRef = (0, $kUtXx$useRef)(null);
    let { dropIndicatorProps: dropIndicatorProps, isHidden: isHidden, isDropTarget: isDropTarget } = dragAndDropHooks.useDropIndicator(props, dropState, buttonRef);
    if (isHidden) return null;
    let level = dropState && props.target.type === 'item' ? (((_dropState_collection_getItem = dropState.collection.getItem(props.target.key)) === null || _dropState_collection_getItem === void 0 ? void 0 : _dropState_collection_getItem.level) || 0) + 1 : 1;
    return /*#__PURE__*/ (0, $kUtXx$react).createElement($2f5eaf4a2a47b4cf$var$TreeDropIndicatorForwardRef, {
        ...props,
        dropIndicatorProps: dropIndicatorProps,
        isDropTarget: isDropTarget,
        ref: ref,
        buttonRef: buttonRef,
        level: level
    });
}
function $2f5eaf4a2a47b4cf$var$TreeDropIndicator(props, ref) {
    let { dropIndicatorProps: dropIndicatorProps, isDropTarget: isDropTarget, buttonRef: buttonRef, level: level, ...otherProps } = props;
    let { visuallyHiddenProps: visuallyHiddenProps } = (0, $kUtXx$useVisuallyHidden)();
    let renderProps = (0, $64fa3d84918910a7$export$4d86445c2cf5e3)({
        ...otherProps,
        defaultClassName: 'react-aria-DropIndicator',
        defaultStyle: {
            position: 'relative',
            // @ts-ignore
            '--tree-item-level': level
        },
        values: {
            isDropTarget: isDropTarget
        }
    });
    return /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...renderProps,
        role: "row",
        "aria-level": level,
        ref: ref,
        "data-drop-target": isDropTarget || undefined
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "gridcell"
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref: buttonRef
    }), renderProps.children));
}
const $2f5eaf4a2a47b4cf$var$TreeDropIndicatorForwardRef = /*#__PURE__*/ (0, $kUtXx$forwardRef)($2f5eaf4a2a47b4cf$var$TreeDropIndicator);
function $2f5eaf4a2a47b4cf$var$RootDropIndicator() {
    let { dragAndDropHooks: dragAndDropHooks, dropState: dropState } = (0, $kUtXx$useContext)((0, $612b8eb6cb90e02d$export$d188a835a7bc5783));
    let ref = (0, $kUtXx$useRef)(null);
    let { dropIndicatorProps: dropIndicatorProps } = dragAndDropHooks.useDropIndicator({
        target: {
            type: 'root'
        }
    }, dropState, ref);
    let isDropTarget = dropState.isDropTarget({
        type: 'root'
    });
    let { visuallyHiddenProps: visuallyHiddenProps } = (0, $kUtXx$useVisuallyHidden)();
    if (!isDropTarget && dropIndicatorProps['aria-hidden']) return null;
    return /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "row",
        "aria-hidden": dropIndicatorProps['aria-hidden'],
        style: {
            position: 'absolute'
        }
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "gridcell"
    }, /*#__PURE__*/ (0, $kUtXx$react).createElement("div", {
        role: "button",
        ...visuallyHiddenProps,
        ...dropIndicatorProps,
        ref: ref
    })));
}


export {$2f5eaf4a2a47b4cf$export$dfae7d399eea2568 as TreeContext, $2f5eaf4a2a47b4cf$export$8953bccafd7bce87 as TreeStateContext, $2f5eaf4a2a47b4cf$export$7fbedc92909ed28e as Tree, $2f5eaf4a2a47b4cf$export$4b687e3f663d618c as TreeItemContent, $2f5eaf4a2a47b4cf$export$36b5dda0d9bc8f78 as TreeItemContentContext, $2f5eaf4a2a47b4cf$export$53d36ab85dc89436 as TreeItem, $2f5eaf4a2a47b4cf$export$533df5f8efd48cc9 as TreeLoadMoreItem};
//# sourceMappingURL=Tree.module.js.map
